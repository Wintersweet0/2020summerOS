1 各个Lab的实现
0. Lab0
使用 Rust 包管理器 cargo 创建一个 Rust 项目

我们将程序的目标平台设置为 RISC-V，这样我们的代码将可以在 RISC-V 指令集的裸机（Bare Metal）上执行 Rust 代码
生成内核镜像、调整代码的内存布局并在 QEMU 模拟器中启动
封装如输出、关机等一些 SBI 的接口，方便后续开发

首先移除标准库和运行环境依赖，移除 Rust 程序对操作系统的依赖，构建一个独立化可执行的程序
调整内存布局是因为程序默认开始位置和一般OS内核开始位置不一样。
另外也要重写程序入口，准确说是不使用main函数作为入口，在新的入口调用mod的init函数来初始化各个mod
最后是console和print的实现，通过QEMU的OpenSBI启动内核

1. Lab1
RISC-V 中有关中断处理的寄存器和相关流程
如何保存上下文，使得中断处理流程前后，原本正在执行的程序感知不到发生了中断
处理最简单的断点中断和时钟中断

这一章是关于中断处理（exception,interrupt,trap的概念不具体说），中断后需要保存所有通用寄存器，还有CSR寄存器。一般是写汇编来保存通用寄存器，这个和Linux一样。Context结构体来保存一些CSR寄存器状态。然后要实现处理中断(handle_interrupt)，再实现恢复寄存器。
对于处理中断，需要先找到中断入口（将其写入stvec寄存器），以及写入触发中断函数。
这里实现了两个中断，断点和时钟中断，可以尝试写别的中断。另外进程切换也要触发中断

2. Lab2
实现动态内存的分配
了解 QEMU 模拟的 RISC-V Virt 计算机的物理内存
通过页的方式对物理内存进行管理

这一章是关于动态内存分配，需要支持如Vec之类的数据结构，我们借用了Linux的buddy system来实现这个
OpenSBI扫描外设（包括物理内存），保存dtb结果，并将地址存在a1 reg中。实际上地址空间是QEMU分配的，我们只管理DRAM
管理物理内存是使用页帧(frame),每个帧开头地址除以4096（4KB）即它的物理页号。帧是连续的，接下来要实现帧的分配和回收（写一个分配器），分配器的具体算法可以自己写，这里用得是线段树，也可以用栈
3. Lab3
虚拟地址和物理地址的概念和关系
利用页表完成虚拟地址到物理地址的映射
实现内核的重映射

这一章是虚拟地址和物理地址的映射。
每个进程所看到的是自己的地址，这些地址是虚拟地址，OS用页表维护虚拟地址和物理地址的映射
为了实现 Sv39 页表，我们的思路是把一个分配好的物理页（即会自动销毁的 FrameTracker）拿来把数据填充作为页表，而页表中的每一项是一个 8 字节的页表项。
对于页表项，需要获得它的页号，地址，有效位等。512个连续页表项组成一个页，映射之后可以封装成页表
我们需要正确设置不同段（text，data...）的访问权限，某个段可能会占用很多页，他们需要有一个统一的属性。所以我们要先封装内存段（一段连续的页，每一页会映射到一个页帧），之后对页表和内存段进行封装（使用mapping），把所有段放入mapping并给他们一个新的名字MemorySet
发生缺页的页面置换算法略，OS已学过
